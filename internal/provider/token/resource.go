// Generated by LIBLAB | https://liblab.com

package token

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/liblab-sdk/pkg/client"
	"github.com/liblab-sdk/pkg/token"
	"github.com/terraform-provider-liblab/internal/utils"
)

// ensure we implement the needed interfaces
var _ resource.Resource = &TokenResource{}
var _ resource.ResourceWithImportState = &TokenResource{}

// constructor
func NewTokenResource() resource.Resource {
	return &TokenResource{}
}

// client wrapper
type TokenResource struct {
	client *client.Client
}

type TokenResourceModel struct {
	Id        types.Float64 `tfsdk:"id"`
	Name      types.String  `tfsdk:"name"`
	ExpiresAt types.String  `tfsdk:"expires_at"`
	Scope     types.List    `tfsdk:"scope"`
}

func (r *TokenResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_token"
}

func (r *TokenResource) Schema(_ context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{

		Attributes: map[string]schema.Attribute{
			"id": schema.Float64Attribute{
				Description: "id",
				Computed:    true,
				Optional:    true,
				PlanModifiers: []planmodifier.Float64{
					float64planmodifier.RequiresReplace(),
				},
			},

			"name": schema.StringAttribute{
				Description: "name",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},

			"expires_at": schema.StringAttribute{
				Description: "expires_at",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},

			"scope": schema.ListAttribute{
				Description: "scope",
				Required:    true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},

				ElementType: types.StringType,
			},
		},
	}
}

func (r *TokenResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	apiClient, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = apiClient
}

func (r *TokenResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var dataModel TokenResourceModel
	utils.PopulateModelData(ctx, &dataModel, resp.Diagnostics, req.State.Get)

	if resp.Diagnostics.HasError() {
		return
	}

	Id := dataModel.Id.ValueFloat64()

	clientResponse, err := r.client.Token.GetById(ctx, Id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected error calling Token.GetById",
			err.Error(),
		)

		return
	}

	token := clientResponse.Data

	dataModel.Id = utils.NullableFloat64(token.GetId())

	dataModel.Name = utils.NullableString(token.GetName())

	dataModel.ExpiresAt = utils.NullableString(token.GetExpiresAt())

	dataModel.Scope = utils.ToList(ctx, token.Scope, types.StringType, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &dataModel)...)
}

func (r *TokenResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var dataModel TokenResourceModel
	utils.PopulateModelData(ctx, &dataModel, resp.Diagnostics, req.Plan.Get)

	if resp.Diagnostics.HasError() {
		return
	}

	requestBody := token.CreateTokenRequest{
		Name:      dataModel.Name.ValueStringPointer(),
		Scope:     utils.MapList(utils.FromListToPrimitiveSlice[string](ctx, dataModel.Scope, &resp.Diagnostics), func(val string) token.Scope { return token.Scope(val) }),
		ExpiresAt: dataModel.ExpiresAt.ValueStringPointer(),
	}

	clientResponse, err := r.client.Token.Create(ctx, requestBody)

	if err != nil {
		resp.Diagnostics.AddError(
			"Error Creating Token",
			err.Error(),
		)

		return
	}

	token := clientResponse.Data
	dataModel.Id = utils.NullableFloat64(token.GetId())

	dataModel.Name = utils.NullableString(token.GetName())

	dataModel.ExpiresAt = utils.NullableString(token.GetExpiresAt())

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &dataModel)...)
}

func (r *TokenResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var dataModel = &TokenResourceModel{}
	utils.PopulateModelData(ctx, &dataModel, resp.Diagnostics, req.State.Get)

	if resp.Diagnostics.HasError() {
		return
	}

	Id := dataModel.Id.ValueFloat64()

	_, err := r.client.Token.Remove(ctx, Id)

	if err != nil {
		resp.Diagnostics.AddError(
			"Error Deleting Token",
			err.Error(),
		)
	}
}

func (r *TokenResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
}

func (r *TokenResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Retrieve import ID and save to id attribute
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
